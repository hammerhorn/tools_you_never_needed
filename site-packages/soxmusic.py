#!/usr/bin/env python
#coding=utf8
"""
Trying to create a simpler implementation than <soxmusic.Pitch>
"""
import math
import os
import subprocess
import time

#import numpy as np
#import sounddevice as sd

import textwidgets
import things

VOL = 0.1
A_4 = 440.0
C_ZERO = A_4 * 2 ** -4.75
DIVS = 12.0

NOTENAMES = (
    ('C', 'B#'),
    ('C♯/D♭', 'C#', 'Db'),
    ('D'),
    ('D♯/E♭', 'D#', 'Eb'),
    ('E', 'Fb'),
    ('F', 'E#'),
    ('F♯/G♭', 'F#', 'Gb'),
    ('G'),
    ('G♯/A♭', 'G#', 'Ab'),
    ('A'),
    ('A♯/B♭', 'A#', 'Bb'),
    ('B', 'Cb'))


def _number2letter(number):
    """
    Converts _scale_deg or _hs_above(C_ZERO) to polished notename
    """
    return NOTENAMES[int(number % DIVS)][0]

#_number2letter = lambda number: NOTENAMES[int(number % DIVS)][0]
# define minus, add, lt and gt

class Pitch(things.Thing):
    """
    Holds information about a musical pitch (frequency in Hz, octave,
    notename, cents).  Uses sox command to play the pitches audibly.
    C4+0 is the default.
    """
    def __init__(self, *, octave=4.0, notename='C', cents=0.0, freq=None):
        """
        Keywords are now enforced, positional args not allowed
        Currently works with the following:
        Pitch(octave=, notename=, cents=)
        Pitch(freq=frequency)
        Pitch(octave=)
        Pitch(octave=, cents=)
        """
        super().__init__()
        self.freq = freq

        if freq:
            self._set_tuple_from_number()
        else:
            self.note_tuple = octave, notename[0].upper() + notename[1:], cents
            self._set_freq_from_tuple()
            if octave != int(octave):
                self._set_tuple_from_number()
            self.note_tuple = (
                self._octave,
                _number2letter(self._scale_deg),
                self._cents)
        self._simplify_cents()

    def __str__(self):#, ascii=False):
        return ''.join((
            f'    {self.note_tuple[1]:>5}{int(self.note_tuple[0]):.0f}',
            f'({self.note_tuple[2]/100:+.2f})  {self.freq:.2f} Hz'))

    def __add__(self, float_val):
        """ a certain number of equal-tempered half-steps"""
        return Pitch(
            octave=self.note_tuple[0],
            notename=self.note_tuple[1],
            cents=self.note_tuple[2] + float_val * 100)

    @property
    def _octave(self):
        """
        Assumes there is either self.freq or self.note_tuple.
        Returns a float ending in '.0' (floating-point integer).
        """
        oct_number = math.log(self.freq / C_ZERO)/math.log(2) if self.freq else\
            self.note_tuple[0]
        return math.modf(oct_number)[1]

    @property
    def _cents(self):
        return math.modf(self.hs_above(C_ZERO))[0] * 100.0 % 100

    @property
    def _scale_deg(self):
        """
        Assumes that either self.freq or self.note_tuple[1] is not None,
        and if using self.note_tuple[1], that the given notename makes sense.

	    Always returns an int
	    """
        if self.freq:
            return int(int(self.hs_above(C_ZERO)) % int(DIVS))
        for index, name_tuple in enumerate(NOTENAMES):
            if self.note_tuple[1] in tuple(name_tuple):
                return index
        return None

    def _set_tuple_from_number(self):
        """
        Assumes self.freq is not None
        """
        self.note_tuple = (
            self._octave,
            _number2letter(self._scale_deg),
            self._cents)

    def _set_freq_from_tuple(self):
        """
        Assumes self.note_tuple exists and that the notename makes sense.
        if octave is not equal to an integer, all the values should be adjusted
        """
        octave, _, cents = self.note_tuple
        self.freq = C_ZERO * 2 ** (
            octave + (self._scale_deg + cents / 100) / DIVS)

    def hs_above(self, some_freq):
        """
        Currently assumes self.freq.  FIX THIS.
        """
        if self.freq:
            return DIVS * (math.log(self.freq / some_freq) / math.log(2))
        return None

    def _simplify_cents(self):
        """
        Used by the freq version of __init__() to correct notename,
        octave, and cents.
        """
        octave, note_name, cents = self.note_tuple
        if cents > 50.0:
            note_name = _number2letter(self._scale_deg + 1.0)
            if note_name == 'C':
                octave += 1.0
            cents -= 100.0
        elif cents < -50.0:
            note_name = _number2letter(self._scale_deg - 1.0)
            if note_name == 'B':
                octave -= 1.0
            cents += 100.0
        self.note_tuple = (octave, note_name, cents)

    def play_sox(self, voice='sin'):
        """
        Currently uses a system call to sox
        """
        note_length = .15
        command = f'play -n synth {note_length} {voice} {self.freq} vol {VOL}'
        try:
            proc = subprocess.Popen(command, shell=True)
            proc.wait()
        finally:
            pass

    @property
    def abc_str(self):
        """
        return ABC notation as a string
        """
        if len(self.note_tuple[1]) == 1:
            note = f'{self.note_tuple[1]} '
        else:
            note = f'^{self.note_tuple[1][0]} '

        out_str_list = [f"X: 1\n"
                        f"T: {self}\n"
                        f"C:\n"
                        f"M: 4/4\n"
                        f"L: 1/4\n"
                        f"K: C\n"]

        out_str_list.append(f'{note.rstrip()}4|]\n')
        return ''.join(out_str_list)


    def play_midi(self, player='audacious'):  # , supress_stdout=False):
        """
        Play midi file with designated player, audacious by default
        If X is not available, you can use timidity
        """
        self.write_abc_file()

        # come up with a better filename than "test"
        proc = subprocess.Popen((
            'abc2midi __data__/test.abc -Q 140 &&'
            f' {player} __data__/test1.mid&'), shell=True)
        proc.wait()
        textwidgets.notify("'test1.mid' written")

    def write_abc_file(self, quiet=False):
        """
        write ABC data to a file
        """
        filename = '__data__/test.abc'
        with open(filename, 'w') as handler:
            handler.write(self.abc_str)
        if not quiet:
            textwidgets.notify(f"'{filename}' written")

    def abc2png(self):
        """
        uses multiple system calls to:
        - generate postscript from a .abc file
        - convert that .ps file to .png
        - crop off extra space at the bottom and save a copy
        - display the image
        """
        # some of this is probably duplicate code
        shell_commands = (
            f'abcm2ps __data__/pitch{self.freq}.abc -O __data__/'\
            f'pitch{self.freq}.ps > /dev/null',
            'gs -dSAFER -r100 -sDEVICE=pngalpha -o '\
            '__data__/pitch{self.freq}.png __data__/pitch{self.freq}.ps > /dev/null',
            'convert __data__/pitch{self.freq}.png -crop 850x200+0+30 '\
            '__data__/pitch{self.freq}-cropped.png 2> /dev/null')

        for command in shell_commands:
            proc = subprocess.Popen(command, shell=True)
            proc.wait()
            textwidgets.notify(f"'{command}' has been executed")

    def create_png(self):
        """
        create postscript-format staff notation
        """
        self.write_abc_file()
        self.abc2png()

    def open_staff(self):
        """
        create a staff image and pop it open in the default image viewer
        """
        self.create_png()
        proc = subprocess.Popen(
            f'xdg-open __data__/test-cropped.png&',
            shell=True)
        proc.wait()

            #os.remove('tmp.wav')
#    def sdplay(self):
#        sps = 44100
#        duration = 5.0
#        atten = 0.
#        each_sample_number = np.arange(duration * sps)
#        waveform = np.sin(2 * np.pi * each_sample_number * self.freq / sps)
#        waveform_quiet = waveform * atten
#        sd.play(waveform_quiet, sps)
#        time.sleep(duration)
#        sd.stop()

class Note(Pitch):
    """
    a Pitch with a duration, probably doesn't need to be a separate class
    """
    def __init__(self, a_pitch, duration):
        super(Note, self).__init__(freq=a_pitch.freq)
        self.duration = duration

    def play(self, voice='squ'):
        """
        Currently uses a system call to sox
        """
        proc = subprocess.Popen(
            f'play -n synth {self.duration} {voice} {self.freq} vol {VOL} > /dev/null 2>&1',
            shell=True)
        proc.wait()
        #  traceback if OSError?


class PitchSet(things.Thing):
    """
    defines a key or harmonic mode
    """
    def __init__(self, *, et=12, pattern=None, start_pitch=Pitch(octave=4, notename='C')):
        """
        'pattern' is list which acts as a filter, e.g.,
        [1, 3, 5, 6, 8, 10, 12] would define the diatonic major scale.
        """
        super().__init__()
        if not pattern:
            pattern = list(range(1, int(et+1)))
        if 1 in pattern:
            self.pitches = [start_pitch]
            del pattern[pattern.index(1)]
        else:
            self.pitches = []
        for x in range(int(et) - 1):
            if x + 2 in pattern:
                f = start_pitch.freq * 2 ** ((x + 1) / float(et))
                self.pitches.append(Pitch(freq=f))

    def __str__(self):
        out_str_list = ['\n']
        for pitch in self.pitches:
            out_str_list.append(f'{pitch}\n')
        return ''.join(out_str_list)

    def __getitem__(self, index):
        return self.pitches[index]

    def play(self, voice='saw'):
        """
        Arpeggiate this PitchSet using the sox command.
        """
        Note(self.pitches[0], .05).play(voice)
        time.sleep(.03)
#        for x in range(int((20 + len(self.pitches)) / len(self.pitches))):
        for pitch in self.pitches[1:]:
            Note(pitch, .05).play(voice)
            time.sleep(.03)

        for pitch in reversed(self.pitches[:-1]):
            Note(pitch, .05).play(voice)
            time.sleep(.03)

    def play_chord(self, wform='pl'):
        """
        Currently uses a system call to sox
        """
        note_length = 2
        command_list = [f'sox -n tmp.wav synth {note_length} ']
        for pitch in self.pitches:
            command_list.append(f'{wform} {pitch.freq:.4g} ')
        command_list.append(f'vol +{VOL * 3:.2} > /dev/null 2>&1 && mplayer tmp.wav')
        command = ''.join(command_list)
        print(command)
        try:
            proc = subprocess.Popen(command, shell=True)
            proc.wait()
        finally:
            os.remove('tmp.wav')


class PitchSequence(things.Thing):
    """
    Pitches with a sequence (i.e., Pitches can appear any number of times)
    """
    def __init__(self, pitch_set=PitchSet(pattern=[1, 3, 5, 6, 8, 10, 12]),
                 seq=(1, 1, 5, 5, 6, 6, 5, 4, 4, 3, 3, 2, 2, 1)):
        super().__init__()
        self.p_seq = []
        for x in seq:
            self.p_seq.append(pitch_set[x - 1])

    def play(self):
        """
        play this sequence using sox
        """
        for pitch in self.p_seq:
            pitch.play_sox()

    def __getitem__(self, index):
        return self.p_seq[index]

    def __str__(self):
        return self.p_seq.__str__()

    def __len__(self):
        return len(self.p_seq)

    def pprint(self):
        """
        Display as formatted columns.
        """
        out_str_list = []
        for x in self.p_seq:
            out_str_list.append(x.__str__())
        out_str = '\n'.join(out_str_list)
        print(f"\n{out_str}\n")
