#!/usr/bin/env python
#coding=utf8
"""
This kind of works, but is not well tested and not very "safe".

Simplified version which does not inherit from class SoundWave <- Wave <- Thing
or use a Scalar object for the frequency.
"""
import math
import os
import subprocess
import time

#import numpy as np
#import sounddevice as sd

import things

VOL = 0.1
A_4 = 440.0
C_ZERO = A_4 * 2 ** -4.75
DIVS = 12.0

NOTENAMES = (
    ('C', 'B#'),
    ('C♯/D♭', 'C#', 'Db'),
    ('D'),
    ('D♯/E♭', 'D#', 'Eb'),
    ('E', 'Fb'),
    ('F', 'E#'),
    ('F♯/G♭', 'F#', 'Gb'),
    ('G'),
    ('G♯/A♭', 'G#', 'Ab'),
    ('A'),
    ('A♯/B♭', 'A#', 'Bb'),
    ('B', 'Cb'))


def _number2letter(number):
    """
    Converts _scale_deg or _hs_above(C_ZERO) to polished notename
    """
    return NOTENAMES[int(number % DIVS)][0]

# define minus, add, lt and gt

class Pitch(things.Thing):
    """
    Holds information about a musical pitch (frequency in Hz, octave, notename,
    cents).  Uses sox command to play the pitches audibly.
    """
    def __init__(self, octave=4.0, notename='C', cents=0.0, freq=None):
        """
        Currently works with the following:
        Pitch(octave, notename, cents)
        Pitch(freq=frequency)
        Pitch(octave=)
        Pitch(octave=, cents=)
        """
        super().__init__()
        self.freq = freq

        if freq:
            self.note_tuple = self._freq2tuple()
            self._simplify_cents()
        else:
            self.note_tuple = octave, notename[0].upper() + notename[1:], cents
            self.freq = self._tuple2freq()
            if octave != int(octave):
                self.note_tuple = self._freq2tuple()
            self.note_tuple = (
                self._octave,
                _number2letter(self._scale_deg),
                self._cents)

    def __str__(self):#, ascii=False):
        return ''.join((
            f'    {self.note_tuple[1]:>5}{int(self.note_tuple[0]):.0f}',
            f'({self.note_tuple[2]/100:+.2f})  {self.freq:.2f} Hz'))

    def __add__(self, float_val):
        """ a certain number of equal-tempered half-steps"""
        return Pitch(self.note_tuple[0], self.note_tuple[1], self.note_tuple[2] + float_val * 100)

    @property
    def _octave(self):
        """
        Assumes there is either self.freq or self.note_tuple.
        Returns a float ending in '.0' (floating-point integer).
        """
        if self.freq:
            oct_number = math.log(self.freq / C_ZERO)/math.log(2)
        else:
            oct_number = self.note_tuple[0]
        return math.modf(oct_number)[1]

    @property
    def _cents(self):
        cents = math.modf(self._hs_above(C_ZERO))[0] * 100.0
        return cents % 100

    @property
    def _scale_deg(self):
        """
        Assumes that either self.freq or self.note_tuple[1] is not none,
        and if using self.note_tuple[1], that the given notename makes sense.

	    Always returns an int
	    """
        if self.freq:
            return int(int(self._hs_above(C_ZERO)) % int(DIVS))
        for index, name_tuple in enumerate(NOTENAMES):
            if self.note_tuple[1] in tuple(name_tuple):
                return index
        return None


    def _freq2tuple(self):  # WORKS
        """
        Assumes self.freq is not None
        """
        notename = _number2letter(self._scale_deg)  # WORKS
        return (self._octave, notename, self._cents)  # WORKS


    def _tuple2freq(self):
        """
        Assumes self.note_tuple exists and that the notename makes sense.
        if octave is not equal to an integer, all the values should be adjusted
        """
        octave, _, cents = self.note_tuple
        return C_ZERO * 2 ** (octave + (self._scale_deg + cents / 100) / DIVS)

    def _hs_above(self, some_freq):
        """
        Currently assumes self.freq.  FIX THIS.
        """
        if self.freq:
            return DIVS * (math.log(self.freq / some_freq) / math.log(2))
        return None

    def _simplify_cents(self):
        """
        Used by the freq version of __init__() to correct notename, octave, and
        cents.
        """
        octave, note_name, cents = self.note_tuple
        if cents > 50.0:
            note_name = _number2letter(self._scale_deg + 1.0)
            if note_name == 'C':
                octave += 1.0
            cents -= 100.0
        elif cents < -50.0:
            note_name = _number2letter(self._scale_deg - 1.0)
            if note_name == 'B':
                octave -= 1.0
            cents += 100.0
        self.note_tuple = (octave, note_name, cents)

    def play(self, voice='sin'):
        """
        Currently uses a system call to sox
        """
        note_length = .15
        #note_length = .3
        #note_length = .05
        command = f'play -n synth {note_length} {voice} {self.freq} vol {VOL} > /dev/null 2>&1'
        try:
            proc = subprocess.Popen(command, shell=True)
            proc.wait()
        finally:
            pass
            #os.remove('tmp.wav')
#    def sdplay(self):
#        sps = 44100
#        duration = 5.0
#        atten = 0.
#        each_sample_number = np.arange(duration * sps)
#        waveform = np.sin(2 * np.pi * each_sample_number * self.freq / sps)
#        waveform_quiet = waveform * atten
#        sd.play(waveform_quiet, sps)
#        time.sleep(duration)
#        sd.stop()

class Note(Pitch):
    """
    a Pitch with a duration, probably doesn't need to be a separate class
    """
    def __init__(self, a_pitch, duration):
        super(Note, self).__init__(freq=a_pitch.freq)
        self.duration = duration

    def play(self, voice='squ'):
        """
        Currently uses a system call to sox
        """
        proc = subprocess.Popen(
            f'play -n synth {self.duration} {voice} {self.freq} vol {VOL} > /dev/null 2>&1',
            shell=True)
        proc.wait()
        #  traceback if OSError?


class PitchSet(things.Thing):
    """
    defines a key or harmonic mode
    """
    def __init__(self, et=12, pattern=None, start_pitch=Pitch(4, 'C')):
        """
        'pattern' is list which acts as a filter, e.g.,
        [1, 3, 5, 6, 8, 10, 12] would define the diatonic major scale.
        """
        super().__init__()
        if not pattern:
            pattern = list(range(1, int(et+1)))
        if 1 in pattern:
            self.pitches = [start_pitch]
            del pattern[pattern.index(1)]
        else:
            self.pitches = []
        for x in range(int(et) - 1):
            if x + 2 in pattern:
                f = start_pitch.freq * 2 ** ((x + 1) / float(et))
                self.pitches.append(Pitch(freq=f))

    def __str__(self):
        out_str_list = ['\n']
        for pitch in self.pitches:
            out_str_list.append(f'{pitch}\n')
        return ''.join(out_str_list)

    def __getitem__(self, index):
        return self.pitches[index]

    def play(self, voice='saw'):
        """
        Arpeggiate this PitchSet using the sox command.
        """
        Note(self.pitches[0], .05).play(voice)
        time.sleep(.03)
#        for x in range(int((20 + len(self.pitches)) / len(self.pitches))):
        for pitch in self.pitches[1:]:
            Note(pitch, .05).play(voice)
            time.sleep(.03)

        for pitch in reversed(self.pitches[:-1]):
            Note(pitch, .05).play(voice)
            time.sleep(.03)

    def play_chord(self, wform='pl'):
        """
        Currently uses a system call to sox
        """
        note_length = 2
        command_list = [f'sox -n tmp.wav synth {note_length} ']
        for pitch in self.pitches:
            command_list.append(f'{wform} {pitch.freq:.4g} ')
        command_list.append(f'vol {VOL * 2} > /dev/null 2>&1 && mplayer tmp.wav')
        command = ''.join(command_list)
        print(command)
        try:
            proc = subprocess.Popen(command, shell=True)
            proc.wait()
        finally:
            os.remove('tmp.wav')


class PitchSequence(things.Thing):
    """
    Pitches with a sequence (i.e., Pitches can appear any number of times)
    """
    def __init__(self, pitch_set=PitchSet(pattern=[1, 3, 5, 6, 8, 10, 12]),
                 seq=(1, 1, 5, 5, 6, 6, 5)):
        super().__init__()
        self.p_seq = []
        for x in seq:
            self.p_seq.append(pitch_set[x - 1])

    def play(self):
        """
        play this sequence using sox
        """
        for pitch in self.p_seq:
            pitch.play()

    def __getitem__(self, index):
        return self.p_seq[index]

    def __str__(self):
        return self.p_seq.__str__()

    def __len__(self):
        return len(self.p_seq)

    def pprint(self):
        """
        Display as formatted columns.
        """
        out_str_list = []
        for x in self.p_seq:
            out_str_list.append(x.__str__())
        out_str = '\n'.join(out_str_list)
        print(f"\n{out_str}\n")
