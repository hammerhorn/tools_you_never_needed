#!/usr/bin/env python3
#coding=utf8
"""
Contains Tonerow class.

Ought to be merged with <cjh.music> module
"""
import random
import subprocess
import time

import matplotlib.pyplot as plt # only needed if there is X
from termcolor import colored

from soxmusic import Pitch, PitchSequence, PitchSet
import textwidgets
from things import Thing


class Tonerow(Thing):
    """
    A shuffled, equal-tempered sequence in which each tone is used
    exactly once; it really ought to inherit from pitchsequence, but
    fuck it
    """
    def __init__(self, length=12, int_list=None):
        super().__init__()
        self.seq = int_list if int_list else list(range(length))
        self.pseq = None # this line is not really necessary
        self.basename = None # this line is not really necessary
        self.shuffle()

    def shuffle(self):
        """
        shuffle the range
        """
        random.shuffle(self.seq)
        self.pseq = PitchSequence(
            PitchSet(len(self)), [i + 1 for i in self.seq])
        self.basename = self.generate_basename()

            ###################
            # numpy is slower #
            ###################

#            for count in range(length):
                # for each number in the list, swap with contents of
                # random index
                # max_index = last_index - count
#                max_index = count
#                random_index = random.randint(0, max_index)
#                self.seq[max_index], self.seq[random_index] =\
#                    self.seq[random_index], self.seq[max_index]

    def __str__(self):
        return str(self.seq)[1:-1].replace(',', '')

    def __repr__(self):
        return self.label

    def __len__(self):
        return len(self.seq)

    def __getitem__(self, index):
        return self.pseq[index]

    def draw_list_play(self):
        """
        draw, list, play - not sure this needs to exist really
        """
        self.draw()
        self.listfreqs()
        self.write_abc_file()
        self.play_midi()
        #self.plot()
        #self.play()

    def play(self):
        """
        play tonerow
        """
        self.pseq.play()


    def plot(self, quiet=False):
        """
        plot tonerow contour with matplotlib
        """
        #import matplotlib.pyplot as plt
        if not quiet:
            print('\nClose Pyplot window to continue....')
        #try:

        f = plt.figure(figsize=(6,1.625))
        #f.set_figwidth(6)
        #f.set_figheight(4)
  
        plt.axis([-0.5, len(self)-0.5, -0.5, len(self)-0.5])

        # naming the x axis
        plt.xlabel('sequence')
        # naming the y axis
        plt.ylabel('musical pitch')

        plt.plot(list(range(len(self))), self.seq, 'bo')  # , ms=10.0)
        plt.show()  # list/range -- edit this
        #plt.display(f)
        #finally:
        #    if not quiet:
        #        termctl.clear()
            
    def draw(self, get_str=False, cntrl_chrs=True, heading=True):
        """
        draw tonerow diagram
        """
        out_str_lst = ['\n\n']
        maximum = len(self)
        if heading:
            #if maximum < 12:
            out_str_lst.append(' ')
            out_str_lst.append(str(self.seq))

            hrule_width = int(round(2.91666 * maximum)) + 7
            out_str_lst.extend(('\n', '=' * hrule_width, '\n\n'))

        for row in range(maximum):
            str_row_lst = [f' {maximum - row - 1:>2} ']
            for index in range(maximum):
                if self.seq[index] == maximum - row - 1:
                    if cntrl_chrs:
                        args = ()
                        kwargs = {'attrs': ['reverse', 'bold']}
                        str_row_lst.append(colored('   ', *args, **kwargs))
                    else:
                        str_row_lst.append('[*]')
                else:
                    str_row_lst.append('. .')
                str_row = ''.join(str_row_lst)
            out_str_lst.extend([str_row, '\n'])
        out_str_lst.append('\n')
        out_str = ''.join(out_str_lst)
        if get_str:
            return out_str
        print(out_str)
        return None

    def reverse(self):
        """
        reverse the tonerow in place
        """
        self.seq = list(reversed(self.seq))
        self.pseq = PitchSequence(
            PitchSet(len(self), start_pitch=self._get_lowest_tone()), [i + 1 for i in self.seq])
        return self

    def invert(self):
        """
        inverts hi with lo tones (in place)
        """
        self.seq = [len(self) - i - 1 for i in self.seq]
        self.pseq = PitchSequence(
            PitchSet(len(self), start_pitch=self._get_lowest_tone()), [i + 1 for i in self.seq])
        return self

    def rotate(self):
        """
        rotate
        """
        backup = tuple(self.seq)
        for outer, _ in enumerate(backup):
            for inner, _ in enumerate(backup):
                if backup[inner] == outer:
                    self.seq[outer] = len(backup) - inner - 1
        self.pseq = PitchSequence(
            PitchSet(len(self), start_pitch=self._get_lowest_tone()), [i + 1 for i in self.seq])
        #self.transpose(1)  # Covering up a bug rather than understanding it
        return self

    def transpose(self, interval):
        """
        transpose the row by an interval up or down
        """
        p_set = PitchSet(len(self), start_pitch=self._get_lowest_tone() + interval)
        self.pseq = PitchSequence(p_set, seq=[i + 1 for i in self.seq])
        return self

    def _get_lowest_tone(self):
        """
        return the lowest-pitched Pitch in this Tonerow - this should be an attribute
        """
        freqs = [i.freq for i in self.pseq]
        min_freq = min(freqs)
        return Pitch(freq=min_freq)

    def listfreqs(self, get_str=False):
        """
        print the notenames and frequencies of the row's tones
        """
        out_str_list = []
        for pitch in self.pseq:
            out_str_list.append(f'\t{pitch.__str__()}\n')
        out_str = ''.join(out_str_list)
        if get_str:
            return out_str
        print(out_str)
        return None

    def generate_abc_str(self):
        """
        return ABC notation as a string
        """
        abc_list = []
        for tone in self:
            #if tone.note_name not in ('A', 'A♯/B♭', 'B'):
            #    notename = tone.note_name.lower()
            #else:
            #    notename = tone.note_name
            if len(tone.note_tuple[1]) == 1:
                current_note = '=%s ' % tone.note_tuple[1]
            else:
                current_note = '^%s ' % tone.note_tuple[1][0]
            abc_list.append(current_note)

        out_str_list = [f"X: 1\n"
                        f"T: Tonerow {self.generate_basename()}\n"
                        f"C:\n"
                        f"M: {len(self)}/4\n"
                        f"L: 1/4\n"
                        f"K: C\n"]

        out_str_list.extend(abc_list)
        out_str_list.append('|]\n')
        return ''.join(out_str_list)

    def generate_basename(self):
        """
        Convert sequence to hex and this will be the basename
        """
        bname_list = []
        for i in self.seq:
            bname_list.append(hex(i)[2:].upper())
        return ''.join(bname_list)

    def play_midi(self, player='timidity', supress_stdout=False):
        """
        Play midi file with designated player, timidity by default
        """
        self.basename = self.generate_basename()
        self.write_abc_file(quiet=supress_stdout) #it might exist...
        proc = subprocess.Popen((
            f'abc2midi __data__/{self.basename}.abc -Q 140 > /dev/null &&'
            f' {player} __data__/{self.basename}1.mid > /dev/null&'), shell=True)
        proc.wait()
        textwidgets.notify(f"'{self.basename}.mid' written")        
        #time.sleep(1.0)
        

    def write_abc_file(self, quiet=False):
        """
        write ABC data to a file
        """
        filename = f'__data__/{self.generate_basename()}.abc'
        abc_str = self.generate_abc_str()
        with open(filename, 'w') as handler:
            handler.write(abc_str)
        if not quiet:
            textwidgets.notify(f"'{filename}' written")

    def abc2png(self):#
        """
        uses multiple system calls to:
        - generate postscript from abc code
        - convert postscript to png
        - crop off extra space at the bottom
        - display the image
        """
        basename = self.generate_basename()
        shell_commands = f'abcm2ps __data__/{basename}.abc -O __data__/{basename}.ps'\
            f' > /dev/null && gs -dSAFER -r100 -sDEVICE=pngalpha -o __data__/'\
            f'{basename}.png __data__/{basename}.ps > /dev/null && convert __data__/{basename}.png '\
            f'-crop 850x200+0+30 __data__/{basename}-cropped.png 2> /dev/null'
        proc = subprocess.Popen(shell_commands, shell=True)
        proc.wait()

        textwidgets.notify(f"'__data__/{basename}.ps' written")
        textwidgets.notify(f"'__data__/{basename}.png' written")
        textwidgets.notify(f"'__data__/{basename}-cropped.png' written")        

    def create_ps(self):
        """
        create postscript-format staff notation
        """
        self.write_abc_file()
        self.abc2png()

    def open_staff(self):
        self.create_ps()
        proc = subprocess.Popen(
            f'xdg-open __data__/{self.generate_basename()}-cropped.png&',
            shell=True)
        proc.wait()

    def shift_h(self, cols):
        """
        shift horizontally
        """
        if cols >= 0:
            for _ in range(cols):
                self.seq.insert(0, self.seq[-1])
                del self.seq[-1]
        else:
            for _ in range(abs(cols)):
                self.seq.extend([self.seq[0]])
                del self.seq[0]
        self.pseq = PitchSequence(
            PitchSet(len(self),
            start_pitch=self._get_lowest_tone()),
            [i + 1 for i in self.seq])

    def shift_v(self, rows):
        """
        shift vertically
        """
        for index in range(len(self)):  # for tone in self:?
            self.seq[index] = self.seq[index] + rows
            if self.seq[index] >= len(self):
                self.seq[index] -= len(self)
            elif self.seq[index] < 0:
                self.seq[index] += len(self)
        self.pseq = PitchSequence(
            PitchSet(len(self),
            start_pitch=self._get_lowest_tone()), 
            [i + 1 for i in self.seq])

    def zero(self):
        """
        shift the row down until the first note is zero
        """
        self.shift_v(-self.seq[0])
        self.pseq = PitchSequence(
            PitchSet(len(self),
            start_pitch=self._get_lowest_tone()),
            [i + 1 for i in self.seq])
        #self.transpose(1)  # Covering up a bug rather than understanding it

    def matrix(self):
        """
        this will print out the full 2-d matrix
        """
        self.zero()
        for num in self.seq:
            print(f'{num:2d} ', end='', flush=True)
        print()
        num = len(self) - self.seq[1]
        print(f'{num:2d} ', end='', flush=True)
        difference = abs(self.seq[0] - num)
        for num in self.seq[1:]:
            nprime = num + difference
            if nprime >= len(self):
                nprime -= len(self)
            print(f'{nprime:2d} ', end='', flush=True)
        print('')
