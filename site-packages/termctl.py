#!/usr/bin/env python
"""
Procedures relating to controlling the terminal
Removing all cross-platform aspects;
now it is just for the terminal on Python 3 on GNU/Linux with GNU bash
"""
import subprocess              # Std Lib
import time

def clear(*args):
    """
    Clear screen; cross-platform; 0 means clear current line,
    else clear n previous lines
    """
    # if no args, clear the screen
    if not args:
        print('[2J\033[H', end='', flush=True)
    elif args[0] == 0:
        print('\r[K\r', end='', flush=True)

    # if arg > 0, erase that many lines back (.i.e., up)
    elif args[0] > 0:
        print('\r[K', end='', flush=True)
        for _ in range(args[0]):
            cursor_v(1)
            print('\r[K', end='', flush=True)

    # if arg < 0, add that many newlines
    elif args[0] < 0:
        print('\n' * abs(args[0]), end='', flush=True)


def cursor_h(x_disp, *args):
    """
    Move cursor in the x direction
    """
    if x_disp < 0:
        print(f'[{abs(x_disp)}D', end='', flush=True)
    elif x_disp > 0:
        print(f'[{x_disp}C', end='', flush=True)
    if args:
        print(args[0], end='', flush=True)


def cursor_v(y_disp, *args):
    """
    Move cursor in the y direction
    """
    if y_disp > 0:
        print(f'[{y_disp}A', end='', flush=True)
    elif y_disp < 0:
        print(f'[{abs(y_disp)}B', end='', flush=True)
    if args:
        print(args[0], end='', flush=True)


def get_keypress(arrows_only=False, fast_on=True):
    """
    if an arrow key is pressed, returns the direction ('up', 'down', 'left', 'right')
    if a letter or symbol is pressed, returns that character"""
    code_dict = {
        'A': 'up',
        'B': 'down',
        'C': 'right',
        'D': 'left'
    }
    direction = None
    pressed = raw_keypress(fast=fast_on)
    if pressed == chr(27):
        pressed = raw_keypress(fast=fast_on)
        if pressed == '[':
            pressed = raw_keypress(fast=fast_on)
            direction = code_dict.get(pressed, None)
            return direction
        return None  # -1
    if not arrows_only:
        return pressed  # -1
    return direction


def raw_keypress(prompt='', fast=False, hide=True):
    """
    Accepts one char of input.  If bash is available, it is not necessary to
        hit <ENTER>.
        """
    key = None
    if not fast:
        print(prompt, end='', flush=True)
    key = subprocess.check_output("bash -c 'read -s -n 1 x; echo -en \"$x\"'", shell=True)
    if len(key) > 1:
        key = key.rstrip('\n')
    if not key:
        key = b' '
    if (fast, hide) == (False, True):
        print('\b \b ', end='', flush=True)
    if not hide:
        print(key.decode('utf-8'), end='', flush=True)
    return key.decode('utf-8')


def height():
    """
    Terminal height.  Only accurate for bash.
    """
    sizey = None
    sizey = int(subprocess.check_output('tput lines', shell=True))
    if not sizey:
        sizey = 25
    return sizey


def hide_cursor():
    """
    Hide cursor
    """
    print('[?25l', end='', flush=True)


#    def input(prompt='>', hide_form=False):
#        """
#        Get input using the appropriate version of Python.
#        """
#        stripped = Ansi.strip_ansi(prompt)
#        if isinstance(stripped, bytes):
#            stripped = stripped.decode('utf8')
#        try:
#            if not hide_form:  # and cls.platform == 'Linux':
#                print(''.join(
#                    (' ' * (len(stripped) - 1), '‚îå', '‚îÄ' * 22, '‚îê')))
#            write(prompt)
#            if not hide_form:  # and cls.platform == 'Linux':
#                easycat.write(
#                    ''.join((
#                        '[', colored(
#                            ' ' * 20, 'yellow', 'on_grey', attrs=['underline',
# 'bold']),
#                        ']‚îÇ', ' ' * (width() - (len(stripped) + 23)), '\n')))
#                #write('\033[G')
#if sysinfo.PLATFORM == 'Windows':
                #    termctl.cursor_v(1)
#                print(''.join(
#                    (' ' * (len(stripped) - 1), '‚îî', '‚îÄ' * 22, '‚îò')))
#                easycat.write('\r')

#                termctl.cursor_v(2)
#                termctl.cursor_h(len(stripped) + 1)
#                easycat.write(''.join(
#                    (Fore.YELLOW, Back.BLACK, Style.BRIGHT, Ansi.UNDERLINE)))
#            return_str = input() # if sysinfo.PY_VERSION == 3 else raw_input()

#        except KeyboardInterrupt:
#            termctl.cursor_v(2)
#            easycat.write('\r\n')
#            cls.exit()
#        else:
#            termctl.cursor_v(-2)
#        finally:
#            easycat.write(Style.RESET_ALL)
#            return return_str


#def text_fx(cmds, text):
#    """
#    p = print to stdout (otherwise, return as str)
#    b = bold
#    u = underline
#    n = suppress newline
#
#    This should just be replaced by termcolor functions.
#    """
#    out_str = text
#    attributes = []
#
#    if 'b' in cmds:
#        attributes.append('bold')
#
#    if 'u' in cmds:
#        attributes.append('underline')
#
#    if 'n' not in cmds:
#        out_str += '\n'
#
#    out_str = colored(out_str, attrs=attributes)
#
#    if 'p' in cmds:
#        print(out_str, end='', flush=True)
#        return None
#    return out_str


def tty(msg):
    """
    Type a message to stdout one letter at a time, like a teletype
    printout.
    """
    try:
        hide_cursor()

        for char in msg:
            print(char, end='', flush=True)
            time.sleep(.019)
    finally:
        print('')
        unhide_cursor()


def unhide_cursor():
    """
    Turns back on a hidden cursor
    """
    print('[?25h', end='', flush=True)


def width():
    """
    terminal width.  works on: bash, android sh
    """
    return int(subprocess.check_output('tput cols', shell=True))


#def write(text, stream=1):
#    """
#    Writes something to stdout immediately, suppressing final endline.
#    """
#    if stream == 1:
#        stream = sys.stdout
#    elif stream == 2:
#        stream = sys.stderr
#    stream.write(text)
#    stream.flush()
