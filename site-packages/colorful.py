#!/usr/bin/env python
#coding=utf8
"""
- color model which converts between ANSI & RGB color codes and Kelvin
  color temperature, and wavelength/frequency

- control of text colors
"""
# Std. Library
import re
import time

# Add-ons
import colortrans

# Local
from fiziko.scalars import Unit
from fiziko.waves import kelvin_to_rgb, EMWave  # SPEED_C
import termctl


# Constants representing ANSI escape sequences
ctrl_char = '\033[%sm'

BLACK = ctrl_char % '38;5;0'
WHITE = ctrl_char % '38;5;231'
ON_CYAN = ctrl_char % '48;5;6'
ON_GREY = ctrl_char % '48;5;7'
UNDERLINE = ctrl_char % '4'
BOLD = ctrl_char % '1'
REVERSE = ctrl_char % '7'
RESET = ctrl_char % '0'

def strip_ansi(in_str):
    ansi_escape = re.compile(r'\x1b[^m]*m')
    return ansi_escape.sub('', in_str)

def cycle_thru_colorboxes(
        mode='ansi', start=0, end=255, delta_t=0.125, truecolor=True, step=1):
    termctl.hide_cursor()
    try:
        for i in range(start, end + 1, step):
            Color(i, mode).draw_box(tc_on=truecolor, label_type=mode)
            time.sleep(delta_t)
            if i != end:
                termctl.cursor_v(10)
    except KeyboardInterrupt:
        termctl.unhide_cursor()        
        termctl.clear(0)

def c_write(fgvalue, fgtype, bgvalue, bgtype, text, truecolor=False,
            get_str=False):
    out_str_list = ['\x1b[38;']
    if fgtype.lower() == 'hex':
        if truecolor:
            out_str_list.append('2;{};{};{}'.format(
                *Color.hex_to_dec(fgvalue)))
        else:
            fgvalue = Color.hex_to_ansi(fgvalue)
            out_str_list.append(f'5;{fgvalue}')
    else:
        out_str_list.append(f'5;{fgvalue}')

    out_str_list.append(';')

    if bgtype.lower() == 'hex':
        if truecolor:
            out_str_list.append('48;2;{};{};{}'.format(
                *Color.hex_to_dec(bgvalue)))
        else:
            bgvalue = Color.hex_to_ansi(bgvalue)
            out_str_list.append(f'48;5;{bgvalue}')
    else:
        out_str_list.append(f'48;5;{bgvalue}')

    out_str_list.append(f'm{text}\x1b[0m')
    out_str = ''.join(out_str_list)
    if get_str:
        return out_str
    print(out_str, end='', flush=True)
    return None


class Color():
    def __init__(self, value, color_type):
        """
        I don't completely understand scope in python.  I'm surprised
        this works.
        """
        self.em_freq = None
        def from_hex():
            self.ansi = self.hex_to_ansi(value)
            self.hexstring = value
            self.kelvins = None
            
        def from_ansi():
            self.ansi = str(value).zfill(2) if value < 10 else value
            self.hexstring = self.ansi_to_hex(value)
            self.kelvins = None

        def from_kelvin():
            self.kelvins = value
            self.hexstring = self.dec_to_hex(*kelvin_to_rgb(value))
            self.ansi = self.hex_to_ansi(self.hexstring)

        def from_freq():
            emw = EMWave(value) #, Unit('Hz'))
            self.hexstring = Color.dec_to_hex(*emw.nm_to_rgb())
            self.ansi = self.hex_to_ansi(self.hexstring)
            self.kelvins = None
            self.em_freq = value

        setter_dict = {
            'ansi': from_ansi,
            'hex': from_hex,
            'kelvin': from_kelvin,
            'freq':from_freq
            }
        setter_dict[color_type]() # fix this for a default case

    def __str__(self):
        out_str = f'\nANSI escape: {self.ansi}\nRGB hexcode: {self.hexstring}'
        if self.kelvins:
            f'{out_str}\ncolor temperature: {self.kelvins}K'
        return out_str

    def draw_box(self, tc_on=False, label_type='hex'):
        """
        Print a box of a certain ANSI color to the screen (0-255).
        """
        box_dict = {
            'ansi': (self.ansi, (4, 16)),
            'hex':(self.hexstring, (8, 12)),
            'kelvin':(f'{self.kelvins}K', (8, 12))
        }

        if self.em_freq:
            box_dict.update({'freq':(f'{self.em_freq:.1e} Hz', (11, 9))})
        termctl.clear(0)
        print('  ', end='', flush=True)
        caption, spacing = box_dict[label_type]

        # let's learn those dict defalts

        c_write(15, 'ansi', 0, 'ansi',
                ''.join(('{:>', str(spacing[0]), '}')).format(caption),
                truecolor=tc_on)
        c_write(self.hexstring, 'hex', self.hexstring, 'hex', ' ' * spacing[1],
                truecolor=tc_on)
        print('')
        for _ in range(9):
            print('  ', end='', flush=True)
            c_write(self.hexstring, 'hex', self.hexstring, 'hex',
                    ' ' * 20, truecolor=tc_on)
            print()

    @staticmethod
    def ansi_to_hex(ansi_code):
        ansi_code = str(ansi_code)
        if len(ansi_code) == 1:
            ansi_code = ansi_code.zfill(2)
        return f'#{colortrans.short2rgb(ansi_code).upper()}'

    @staticmethod
    def dec_to_hex(red, green, blue):
        hex_color_str = ''.join(('#',
                                 hex(red).split('x')[1].zfill(2),
                                 hex(green).split('x')[1].zfill(2),
                                 hex(blue).split('x')[1].zfill(2)))
        return hex_color_str.upper()

    @staticmethod
    def hex_to_dec(hexstring):
        red = int(hexstring[1:3], 16)
        green = int(hexstring[3:5], 16)
        blue = int(hexstring[5:7], 16)
        return red, green, blue

    @staticmethod
    def hex_to_ansi(hexstring):
        return int(colortrans.rgb2short(hexstring[1:])[0])
